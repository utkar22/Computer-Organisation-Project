# RISC Assembler and Simulator

This project implements an assembler and simulator for a 16-bit ISA (Instruction Set Architecture) with specific instructions and opcodes. It also includes a bonus feature for generating a memory access trace scatter plot.

## Assembler

The assembler takes assembly instructions as input and generates a binary file in the specified format. It supports the following features:

- Handling all supported instructions
- Handling labels
- Handling variables
- Error handling for illegal instructions and syntax errors
- Generating distinct readable errors for various conditions

### Input Format

The assembler reads the assembly program from a text file. Each line of the text file can be one of the following types:

- Empty line: Ignored
- Label followed by an instruction
- Instruction
- Variable definition

### Output Format

If the assembly code is error-free, the assembler generates a binary file containing the machine code instructions. Each line of the binary file represents a 16-bit binary number written using 0s and 1s in ASCII.

## Simulator

The simulator loads the binary file generated by the assembler into memory and executes the code starting from address 0. It continues executing instructions until it reaches the halt instruction. After each instruction, the simulator outputs the current state of the program counter (PC) and the register file (RF). Once halted, the simulator prints the memory dump of the entire memory.

### Input Format

The simulator takes a binary file as input, which follows the same format as the output generated by the assembler.

### Output Format

The simulator outputs the following information for each executed instruction:

<PC (8 bits)> <R0 (16 bits)> ... <R6 (16 bits)> <FLAGS (16 bits)>

After execution, the simulator also prints the memory dump, which includes 256 lines representing 16-bit data at each address.

## Memory Access Trace (Bonus)

The bonus feature generates a scatter plot that visualizes the memory access trace during simulation. The plot shows the cycle number on the x-axis and the memory address on the y-axis, indicating which memory addresses are accessed at each cycle.

### Output Format

The memory access trace scatter plot is not described in detail in this README. Please refer to the implementation code for the specific details on how the scatter plot is generated.


## Instruction Set Architecture (ISA)

### Supported Instructions

The ISA supports the following instructions:

1. **Addition**: `add reg1 reg2 reg3`
   - Opcode: `00000`
   - Semantics: Performs `reg1 = reg2 + reg3`. If the computation overflows, the overflow flag is set.

2. **Subtraction**: `sub reg1 reg2 reg3`
   - Opcode: `00001`
   - Semantics: Performs `reg1 = reg2 - reg3`. If `reg3 > reg2`, 0 is written to `reg1` and the overflow flag is set.

3. **Move Immediate**: `mov reg1 $Imm`
   - Opcode: `00010`
   - Semantics: Performs `reg1 = $Imm`, where `$Imm` is an 8-bit immediate value.

4. **Move Register**: `mov reg1 reg2`
   - Opcode: `00011`
   - Semantics: Performs `reg1 = reg2`.

5. **Load**: `ld reg1 mem_addr`
   - Opcode: `00100`
   - Semantics: Loads data from `mem_addr` into `reg1`.

6. **Store**: `st reg1 mem_addr`
   - Opcode: `00101`
   - Semantics: Stores data from `reg1` to `mem_addr`.

7. **Multiply**: `mul reg1 reg2 reg3`
   - Opcode: `00110`
   - Semantics: Performs `reg1 = reg2 x reg3`. If the computation overflows, the overflow flag is set.

8. **Divide**: `div reg3 reg4`
   - Opcode: `00111`
   - Semantics: Performs `reg3 / reg4`. Stores the quotient in `R0` and the remainder in `R1`.
  
9. **Jump**: `jmp target`
   - Opcode: `01000`
   - Semantics: Unconditionally jumps to the instruction at the `target` address.

10. **Jump if Zero**: `jz reg1 target`
    - Opcode: `01001`
    - Semantics: Jumps to the `target` address if `reg1` is zero.

11. **Jump if Not Zero**: `jnz reg1 target`
    - Opcode: `01010`
    - Semantics: Jumps to the `target` address if `reg1` is not zero.

12. **Jump if Carry**: `jc reg1 target`
    - Opcode: `01011`
    - Semantics: Jumps to the `target` address if the carry flag is set.

13. **Jump if Not Carry**: `jnc reg1 target`
    - Opcode: `01100`
    - Semantics: Jumps to the `target` address if the carry flag is not set.

### Instruction Encoding

Each instruction is encoded into a 16-bit binary representation. The encoding format is as follows:

```
| Opcode (5 bits) | Operand 1 (3 bits) | Operand 2 (3 bits) | Operand 3 (3 bits) |
```

The opcode field represents the operation to be performed, and the operand fields specify the registers or memory addresses involved in the instruction.
